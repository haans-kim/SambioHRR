# 근무추정시간 휴일 반영 복잡도 분석

## 🔍 현황 분석

### 1. 데이터 구조 차이점

| 구분 | 주간 근태시간 | 주간 근무추정시간 |
|------|-------------|----------------|
| **테이블** | `claim_data` | `daily_analysis_results` |
| **기준 필드** | `실제근무시간` | `actual_work_hours` |
| **휴일 데이터** | 모든 직원 존재 | 매우 적음 (6-7명/일) |
| **휴일 처리** | 0시간 기록 | 대부분 데이터 없음 |

### 2. 휴일 데이터 현황 (영업센터 예시)

#### claim_data (근태시간)
- 1월 1일: **139명** 기록 (대부분 0시간)
- 1월 27-30일: **140-141명** 기록
- 휴일에도 전 직원 데이터 존재 ✅

#### daily_analysis_results (근무추정시간)
- 1월 1일: **데이터 없음** ❌
- 1월 27-30일: **1-7명**만 기록
- 5월 6일: **6명**만 기록
- 휴일 출근자만 분석 데이터 존재

## 🎯 핵심 문제점

### 문제 1: 휴일 데이터 부재
```sql
-- daily_analysis_results는 휴일에 대부분 직원 데이터가 없음
-- 휴일에 출근한 소수 직원만 데이터 존재
-- 평균 계산 시 분모(직원수)에 영향
```

### 문제 2: 데이터 생성 방식 차이
- **claim_data**: HR 시스템에서 전 직원 일괄 생성
- **daily_analysis_results**: 실제 태그 데이터가 있는 직원만 분석

## 💡 구현 방안 및 복잡도

### 방안 1: 가상 레코드 삽입 (복잡도: 높음) ⚠️
```sql
-- 휴일에 누락된 직원 레코드를 생성해야 함
INSERT INTO daily_analysis_results (
  employee_id,
  analysis_date,
  actual_work_hours,
  leave_hours
)
SELECT
  e.employee_id,
  h.holiday_date,
  0,  -- actual_work_hours
  8.0 -- leave_hours로 8시간 인정
FROM employees e
CROSS JOIN holidays h
WHERE NOT EXISTS (
  SELECT 1 FROM daily_analysis_results dar
  WHERE dar.employee_id = e.employee_id
  AND dar.analysis_date = h.holiday_date
);
```

**문제점**:
- 대량 레코드 삽입 필요 (약 1,000명 × 9일 = 9,000개)
- 다른 필드들 (confidence_score, work_minutes 등) 기본값 처리
- 데이터 무결성 위험

### 방안 2: 쿼리 시점 보정 (복잡도: 중간) ⭐
```sql
-- holidays 테이블과 JOIN하여 계산 시점에 보정
WITH employee_work_data AS (
  SELECT
    e.employee_id,
    e.center_name,
    e.job_grade,
    SUM(COALESCE(dar.actual_work_hours, 0)) as total_work_hours,
    -- 휴일 수 계산
    (SELECT COUNT(*) FROM holidays h
     WHERE h.holiday_date BETWEEN ? AND ?) * 8 as holiday_hours
  FROM employees e
  LEFT JOIN daily_analysis_results dar
    ON dar.employee_id = e.employee_id
    AND dar.analysis_date BETWEEN ? AND ?
  GROUP BY e.employee_id
)
SELECT
  center_name,
  job_grade,
  AVG((total_work_hours + holiday_hours) / days * 7) as weekly_hours
FROM employee_work_data
GROUP BY center_name, job_grade;
```

**장점**:
- 원본 데이터 변경 없음
- 모든 직원 포함 가능

**단점**:
- 복잡한 쿼리 로직
- 성능 영향 가능성

### 방안 3: leave_hours 활용 (복잡도: 낮음) ✅
```sql
-- 기존 leave_hours 필드 활용
WITH adjusted_work AS (
  SELECT
    employee_id,
    SUM(actual_work_hours + COALESCE(leave_hours, 0)) as total_hours
  FROM daily_analysis_results
  WHERE analysis_date BETWEEN ? AND ?
  GROUP BY employee_id
)
-- + holidays 테이블로 누락된 휴일 보정
```

**현재 문제**: leave_hours가 대부분 0으로 기록됨

## 📊 복잡도 비교

| 방안 | 복잡도 | 데이터 변경 | 구현 난이도 | 유지보수 | 추천도 |
|------|--------|------------|------------|---------|--------|
| 가상 레코드 삽입 | 높음 | 대량 삽입 | 어려움 | 어려움 | ⚠️ |
| 쿼리 시점 보정 | 중간 | 없음 | 보통 | 보통 | ⭐⭐ |
| leave_hours 활용 | 낮음 | 일부 수정 | 쉬움 | 쉬움 | ⭐⭐⭐ |

## 🚧 추가 고려사항

### 1. 분석 일관성
- claim_data와 daily_analysis_results의 직원 수가 다름
- 휴일 처리 방식 통일 필요

### 2. 과거 데이터 처리
- 이미 분석된 데이터 재처리 필요성
- 소급 적용 시 영향도

### 3. 성능 영향
- JOIN 연산 증가
- 대량 데이터 처리 시 속도

## 📝 결론

### 근무추정시간 휴일 반영은 가능하지만 복잡도가 높음

**이유**:
1. **데이터 구조 차이**: 휴일에 대부분 직원 데이터 없음
2. **생성 로직 차이**: 태그 기반 분석 vs HR 일괄 생성
3. **보정 복잡성**: 누락 직원 처리 로직 필요

### 권장 접근법

1. **단기 해결책**:
   - 주간 근태시간만 먼저 휴일 반영 (간단)
   - 근무추정시간은 현행 유지

2. **중장기 해결책**:
   - leave_hours 필드 정확히 기록하도록 시스템 개선
   - 휴일/연차 통합 관리 시스템 구축
   - daily_analysis_results 생성 시 휴일 자동 반영

### 예상 작업량
- **근태시간 휴일 반영**: 1-2일 (간단)
- **근무추정시간 휴일 반영**: 3-5일 (복잡)
- **테스트 및 검증**: 2-3일

근태시간을 먼저 적용하고, 근무추정시간은 시스템 개선과 함께 진행하는 것이 효율적입니다.